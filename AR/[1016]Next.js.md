# Next.js

서버 측 렌더링 및 정적 웹 사이트 생성 기능을 갖춘 React 기반 웹 애플리케이션을 제공 하는 민간 회사인 Vercel 이 만든 오픈 소스 웹 개발 프레임워크

- 서버 사이드 렌더링(sever-side rendering(SSR))
- 정적 사이트 생성(static site generation(SSG))
- 증분 정적 재생성(incremental static regeneration(ISR))
- 이미지 최적화
- 자동 폴리필(polyfill) 적용
- 성능 분석

<hr />

### 서버사이드 렌더링(SSR)의 이점

- 로딩

  - 클라이언트 사이드 렌더링(CSR)의 경우 모든 js 파일을 로드하고 사용자는 웹을 보게 되는데 이때까지 사용자는 많은 시간을 대기해야 하는데, 서버사이드 렌더링은 서버에서 자바스크립트르 로딩함으로 클라이언트 측에서는 자바스크립트를 로딩하는 시간이 줄어들게 된다.

- 검색 엔진 최적화(SEO)
  - 클라이언트 사이드 렌더링(CSR)의 경우 자바스크립트가 로드되지 않은 경우 아무런 정보를 보이지 않는다. 구글의 검색엔진의 경우 자바스크립트가 로드되지 않은 페이지를 검색엔진으로 스캔함으로 결론적으로 검색에 아무 페이지도 걸리지 않게 되는데, 서버 사이드 렌더링은 검색엔진이 자바스크립트를 읽는 것이 아닌 서버측에서 자바스크립트, html, css를 만들어 컨텐츠에 직접 업로드 함으로 검색엔진에 게시글이 걸리게 됨 또한 meta 태그를 자유롭게 추가함으로 SEO를 용이하게 할 수 있다

<hr />

### Next.js 시작하기

- Node.js 설치

  - 공식 웹 사이트에서 다운로드하여 설치 가능하며, 버전 12 이상의 Node.js를 사용하는 것을 권장합니다.

- npm 설치

  - npm은 Node.js와 함께 설치됩니다. npm은 JavaScript 라이브러리와 프레임워크를 설치하고 관리하는데 사용됩니다
  - npm 업그레이드 명령어
    ```
    npm install npm@latest -g
    ```

- 텍스트 에디터

  - Next.js를 개발하기 위해서는 적절한 텍스트 에디터가 필요합니다.
  - Visual Studio Code, Sublime Text, Atom, WebStorm 등

- 웹 브라우저

  - Next.js는 웹 브라우저에서 실행되는 프레임워크이므로, 프로젝트를 실행하려면 적절한 웹 브라우저가 필요합니다.
  - Google Chrome, Mozilla Firefox, Safari 등

- Next.js 설치 및 프로젝트 생성

  ```
  npx create-next-app [프로젝트 이름]
  ```

- 프로젝트 실행
  ```
  npm run dev
  ```
  - 위 명령어를 실행하면 Next.js 개발 서버가 시작되며, 브라우저에서 http://localhost:3000 주소로 접속하여 개발 중인 프로젝트를 확인할 수 있습니다.

<hr />

### Next.js 프로젝트의 파일 구조 이해

- 어플리케이션에 사용되는 정적 파일들

  ```
  public
  ├── asset
      ├── image
      └── video
  ```

- 어플리케이션의 기능에 사용되는 소스들

  ```
  component  // 컴포넌트들 모음
  ├── common  // 공통적으로 사용되는 컴포넌트들(ex button, modal)
  └── layout  // 각 페이지들의 전체 레이아웃이자 레이아웃 내부 컴포넌트들의 모임
      ├── layout.tsx
      ├── header.tsx
      ├── nav.tsx
      └── footer.tsx
  pages  // 페이지를 담당하는 컴포넌트(폴더구조로 url 결정)
  │   // (Nextjs에서는 Routing 시스템이 파일/폴더 구조로 되어있음)
  ├── index.tsx
  ├── _app.tsx  // 각 페이지별로 공통적으로 쓰는 부분에 대한 리펙토링을 해주는 곳
  │ // (index.js파일과 같은 역할, 모든 페이지에서 쓰는 스타일, 레이아웃 을 넣어 주기)
  ├── _document.tsx  //  meta태그를 정의 및 전체 페이지의 구조를 만들어준다
  │ // (index.html파일과 같은 역할, html body와 같은 기본 태그들의 속성지정하여 어플리케이션의 구조를 만들어 주는 파일)
  ├── api  // axios를 이용하여 서버와의 통신 로직을 담당
  └── product
      └── [id].tsx

  styles   // 스타일 관련 파일 모음
  ├── globals.css
  └── Home.modules.css

  core     // redux 사용의 경우, core에서 관리하기
  ├── config  // 어플리케이션에서 사용되는 설정들 모음
  ├── provider
  │     ├── helper  // store를 이용하는 공통 로직들 정리
  │     └── provider  // store의 값들을 컨테이너에게 전달해 줌
  └── redux      // Ducks 패턴으로 redux를 정의
  ```

<hr />

### Next.js 특징

- pages 안의 페이지 파일은 코드 최상단에서 import React from 'react'; 를 할 필요 없다.
  (Next.js 안에서는 Component 단위의 파일을 포함하여, pages 단위의 파일에서도 React를 선언하지 않고 바로 사용한다.)

- 쿼리 파라미터는 /search?keyword=something 의 형태이다

  ```
  const Index = ({url}) => {
      return (
          당신이 검색한 키워드는 "{url.query.keyword}" 입니다.
      );
  };
  export default Index;

  // url 주소창에 " localhost:3000/index?keyword=당근 " 이라고 치면 페이지에 아래와 같이 나온다
  // "당신이 검색한 키워드는 "당근" 입니다.
  // 개발자도구를 통해 url props를 열여보면, 다양한 메서드를 확인할 수 있다
  ```

- 페이지 관련 컴포넌트들은 반드시 pages/ 디렉토리에 넣어야 한다

- /pages 내 구성하는 파일명은 pathname파라미터(/post/:id)에서 id 부분을 의미한다. (따라서 파일명과 pathname파라미터를 동일하게 설정해 주어야 한다)
  즉, pages 폴더에 있는 파일은 해당 이름으로 라우팅 된다.
  (pages/post.tsx -> localhost:3000/post)

- 페이지 라우팅 -> <Link href="/경로"> 태그 사용하기

  ```
  <Link href="/about">    // pages 내 about 파일로 라우팅 됨(파일명 = 경로)
      <a> 이동하기 </a>
  </Link>
  ```

  - 만약 <a>태그를 사용하지 않는다면 해당 컴포넌트가 onClick props를 전달받아서 실행할 수 있게 해야한다

- 공용 컴포넌트 사용 (components 폴더 내 생성)
  components/Header.js 파일 생성 (모든 페이지에 공통적으로 쓰일 수 있다)
  components/Layout.js 파일 생성 (공용 컴포넌트를 담은 틀로 쓸 수 있다)
  pages/\_app.js 파일에 담는다

  ```
  // (1) Header.js 페이지 생성

  import Link from 'next/Link';

  const linkStyle = {
  marginRight: '1rem'
  }
  const Header = () => {
  return (
      <div>
      <Link href="/"><a style={linkStyle}> 홈 </a></Link>
      <Link href="/about"><a style={linkStyle}> 소개 </a></Link>
      </div>
  )
  }



  // (2) Layout.js 페이지 생성
  // Layout 내에서, 공용으로 쓸 Header.js 파일을 불러와서 사용한다.

  import Header from './Header';

  const Layout = ({children}) => (
  <div>
      <Header />
      {children}
  </div>
  );

  export default Layout;



  // (3) pages/_app.js 페이지

  import Layout from '../components/Layout';   // layout 컴포넌트 불러온다

  const Index = () => {
  return (
      <Layout>
      이 부분은 Layout의 children에 해당하는 영역에 들어갈 것입니다.
      </Layout>
  )
  }

  export default Index;
  ```

- \_app.tsx (= index.js)
  : 최초로 실행되는 파일이며, 이곳에서 렌더링 하는 값은 무조건 모든 페이지에 영향을 준다.
  페이지를 업데이트 하기전에 원하는 방식으로 페이지를 업데이트 하는 통로이다.

  ```
   // _app.tsx

  import "./globals.css";

  function MyApp({ Component, pageProps }) {
  return <Component ponent {...pageProps} />;
  }

  export default MyApp;
  ```

- getInitialProps 메서드 -> 외부 데이터 가져오기
  데이터를 가져올 때, 어떻게 동작하느냐에 따라 서버 사이드 렌더가 될 수도 있고, 클라이언트 사이드 렌더가 될 수도 있다.
  (동시에 사용할 수 있는 방법 - 실행되는 환경이 SSR일때는 Next.js 서버이고 CSR일때는 브라우저이다.)

  ```
  // pages/SSRTest 생성

  import Layout from '../components/Layout';

  class SSRTest extends React.Component {
  static async getInitialProps ({req}){
      return req ? {from: 'server'} : {from:'client'}
  }

  render() {
      return (
      <Layout>
          이것은  {this.props.from} 에서 실행이 되었다
      </Layout>
      )
  }
  }

  // getInitialProps 메소드에서 실행되어 반환되는 값이, 해당 컴포넌트의 props 값으로 전달된다.
  // getInitialProps 메소드의 파라미터로는, 무조건 서버 측의 request 값이 들어가게 되므로, 클라이언트의 req 값은 undefined가 된다.


  // 주소로 직접 접속하면(http://localhost:3000/ssr-test 직접입력),
  // 'server에서 실행되었다'는 문구가 뜨고,

  // 페이지 라우팅 링크로 들어가게 되면(<Link href="/ssr-test"> 클릭),
  // 'client에서 실행되었다'는 문구가 뜨게 된다.
  ```

- getInitialProps 를 이용하여, API 요청으로 실제 데이터로 fetching을 할 경우 (axios 이용)

  ```
  // pages/SSRTest 수정

  import Layout from '../components/Layout';
  import Axios from 'axios';

  class SSRTest extends React.Component {
  static async getInitialProps ({req}){
      const response = await Axios.get('https://jsonplaceholder.typicode.com/users');
      return {
      users: response.data
      }
  }
  render() {
      const {users} = this.props;

      const userList = users.map(
      user => <li key={user.id}>{user.username}</li>
      )
      return (
      <Layout>
          <ul>
          {userList}
          </ul>
      </Layout>
      )
  }
  }

  export default SSRTest;
  ```

- 동적 콘텐츠 로드 -> dynamic URL 에 기반하여 제공
  [ ] 문법으로 동적 페이지를 생성하는 동적 URL을 만들 수 있다.
  pages/blog라는 폴더를 예시로 들어보자. blog 폴더 내에는 동적 url로 구성되어야 한다.
  이 방법으로는, pages/blog/[id].tsx 파일을 추가할 수 있다.
  파일 명에서 대괄호 안의 [id] 는 동적인 어떤 것이던 router의 쿼리 파라미터로서 id파라미터에 담길 수 있다.

  ```
  // pages/blog/[id].tsx

  import { useRouter } from 'next/router';  // Next.js에서 제공하는 라이브러리로 next/router에서 import받을 수 있다

  export default () => {
  const router = useRouter()   // router 객체 초기화

  return (
      <>
      <h1> blog post!! </h1>
      <p> post id: {router.query.id} </p>
      </>
  )
  }

  // http://localhost:3000/blog/test 경로를 쳐서 이동하면 <p> 태그 내 내용이 아래처럼 보인다
  // post id: test
  ```

- prefetch 기능 -> Link 태그에서 prefetch라는 키워드를 입력한다
  prefetch는 라우팅이 일어나기 전, 데이터를 전부 불러온 후에 라우팅을 일으키는 것을 말한다.

  ```
  <Link prefetch href="/ssr-test"><a> SSR 테스트 </a></Link>
  // 해당 링크를 누를 때 prefetching이 된다
  ```

- 스타일 정의 (특정 컴포넌트 내부에만 해당 vs 전체(글로벌)에 해당)
  style jsx를 사용하면 컴포넌트 내부에 해당 컴포넌트만 스코프를 가지는 css를 만들 수 있다.
  (= single file components)
    ```
    // styled-jsx

    function Heading(props) {

        const variable = "blue";

        return (
        <div className="title">
            <h1>{props.heading}</h1>
            <style jsx>
            {`
                h1 {
                color: ${variable};
                }
            `}
            </style>
        </div>
        );
    }

    export default function Home() {
        return (
        <div>
            // red
            <Heading heading="heading" />
            // block
            <h1>ttt</h1>
        </div>
        );
    }
    ```
    